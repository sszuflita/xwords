package xwords;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import xwords.wordset.CachingWordSet;
import xwords.wordset.ScoredWord;
import xwords.wordset.WordSet;
import xwords.wordset.trie.TrieWordSet;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.stream.Collectors;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class CrosswordBuilder {
    Logger log = LoggerFactory.getLogger(CrosswordBuilder.class);

    private WordSet wordSet;

    public CrosswordBuilder(WordSet wordSet) {
        this.wordSet = wordSet;
    }

    public static CrosswordBuilder fromPath(Path path) throws IOException {
        return new CrosswordBuilder(
                new CachingWordSet(
                        new TrieWordSet(Files.lines(path)
                                .map(line -> {
                                    String[] split = line.split(";");
                                    String word = split[0].toUpperCase();
                                    int score = Integer.parseInt(split[1]);
                                    return new ScoredWord(word, score);
                                })
                                .collect(Collectors.toSet()))));
    }

    public static int compare(Crossword o1, Crossword o2) {
        return (int) Math.round(Math.signum(o2.getScore() - o1.getScore()));

    }

    private static Double ratioOfCompleteness(PartialFill fill) {
        return -1. * fill.getTiles().stream()
                .filter(CrosswordBuilder::tileIsNotEmpty).count() / fill.getTiles().size();
    }

    private static boolean tileIsNotEmpty(Tile tile) {
        return !tile.equals(Tile.EMPTY);
    }

    private static boolean gridIsComplete(Crossword potentialCrossword) {
        return potentialCrossword.toPartialFill().stream()
                .allMatch(CrosswordBuilder::fillIsComplete);
    }

    public Set<Crossword> solveFromGrid(Crossword base) {

        Queue<Crossword> incompleteGrids = new PriorityQueue<>(CrosswordBuilder::compare);
        Set<Crossword> visitedGrids = Sets.newHashSet();

        if (base.toPartialFill().stream().filter(partialFill -> partialFill.getTiles().contains(Tile.EMPTY))
                .count() == 0) {
            return ImmutableSet.of(base);
        }

        incompleteGrids.add(base);

        Set<Crossword> completeGrids = Sets.newHashSet();

        int parallelismFactor = 8;

        while (!incompleteGrids.isEmpty() && completeGrids.size() < 1) {

            List<Crossword> toVisit = Lists.newArrayList();

            for (int i = 0; i < parallelismFactor; i++) {
                Crossword maybeCrossword = incompleteGrids.poll();
                if (maybeCrossword != null) {
                    toVisit.add(maybeCrossword);
                    visitedGrids.add(maybeCrossword);
                }
            }

            Set<Crossword> potentialCrosswords = toVisit.parallelStream().flatMap(crossword -> {
                // parse into partials
                List<PartialFill> partialOrFull = crossword.toPartialFill();
                List<PartialFill> partialsOnly = partialOrFull.stream()
                        .filter(CrosswordBuilder::fillIsIncomplete)
                        .collect(Collectors.toList());

                // choose a partial to fill
                PartialFill partialFill = partialsOnly.stream()
                        .min(Comparator.comparing(CrosswordBuilder::ratioOfCompleteness))
                        .get();

                // find all valid fills
                Set<ScoredWord> validFillOptions = wordSet.validWords(partialFill);

                return validFillOptions.parallelStream()
                        .map(fill -> crossword.withPartialFill(partialFill, fill.getWord(), fill.getScore()))
                        .filter(potentialCrossword -> !visitedGrids.contains(potentialCrossword))
                        .filter(potentialCrossword -> allFillIsValid(potentialCrossword));
            }).collect(Collectors.toSet());
            // identify complete crosswords
            Set<Crossword> newlyCompletedCrosswords = potentialCrosswords.parallelStream()
                    .filter(CrosswordBuilder::gridIsComplete).collect(Collectors.toSet());

            completeGrids.addAll(newlyCompletedCrosswords);

            Set<Crossword> newIncompleteGrids = Sets.difference(potentialCrosswords, newlyCompletedCrosswords);

            incompleteGrids.addAll(newIncompleteGrids);
        }

        return completeGrids;
    }


    private static boolean fillIsIncomplete(PartialFill partialFill) {
        return partialFill.getTiles().contains(Tile.EMPTY);
    }

    private static boolean fillIsComplete(PartialFill fill) {
        return !fill.getTiles().contains(Tile.EMPTY);
    }

    private boolean allFillIsValid(Crossword potentialCrossword) {
        List<PartialFill> partialFills = potentialCrossword.toPartialFill();

        boolean allWordsAreValid = partialFills.stream()
                .allMatch(wordSet::isFillFeasible);

        List<PartialFill> fullFills = partialFills.stream()
                .filter(partialFill -> !partialFill.getTiles().contains(Tile.EMPTY))
                .collect(Collectors.toList());

        boolean areWordsAreUnique = (fullFills.size() == fullFills.stream().collect(Collectors.toSet()).size());

        return allWordsAreValid && areWordsAreUnique;
    }
}
