package xwords;

import com.google.common.collect.Sets;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import xwords.wordset.BasicWordSet;
import xwords.wordset.WordSet;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.stream.Collectors;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class CrosswordBuilder {
    Logger log = LoggerFactory.getLogger(CrosswordBuilder.class);

    private WordSet wordSet;

    public CrosswordBuilder(WordSet wordSet) {
        this.wordSet = wordSet;
    }

    public static CrosswordBuilder fromPath(Path path) throws IOException {
        return new CrosswordBuilder(
                new BasicWordSet(Files.lines(path)
                        .map(word -> word.split(";")[0])
                        .map(String::toUpperCase)
                        .collect(Collectors.toSet())));
    }

    private static int compare(Crossword o1, Crossword o2) {
        return o2.filledTiles() - o1.filledTiles();
    }

    private static Double ratioOfCompleteness(PartialFill fill) {
        return -1. * fill.getLetters().stream()
                .filter(CrosswordBuilder::tileIsNotEmpty).count() / fill.getLetters().size();
    }

    private static boolean tileIsNotEmpty(Tile tile) {
        return !tile.equals(Tile.EMPTY);
    }

    private static boolean gridIsComplete(Crossword potentialCrossword) {
        return potentialCrossword.toPartialFill().stream()
                .allMatch(CrosswordBuilder::fillIsComplete);
    }

    public Set<Crossword> solveFromGrid(Crossword base) {

        Queue<Crossword> incompleteGrids = new PriorityQueue<>(CrosswordBuilder::compare);
        Set<Crossword> visitedGrids = Sets.newHashSet();
        incompleteGrids.add(base);

        Set<Crossword> completeGrids = Sets.newHashSet();

        while (!incompleteGrids.isEmpty() && completeGrids.size() < 1) {

            Crossword crossword = incompleteGrids.poll();
            visitedGrids.add(crossword);

            // parse into partials
            List<PartialFill> partialOrFull = crossword.toPartialFill();
            List<PartialFill> partialsOnly = partialOrFull.stream()
                    .filter(CrosswordBuilder::fillIsIncomplete)
                    .collect(Collectors.toList());

            // choose a partial to fill
            PartialFill partialFill = partialsOnly.stream().sorted(
                    Comparator.comparing(CrosswordBuilder::ratioOfCompleteness))
                    .findFirst().get();


            // find all valid fills
            Set<String> validFillOptions = wordSet.validWords(partialFill);

            Set<Crossword> potentialCrosswords = validFillOptions.parallelStream()
                    .map(fill -> crossword.withPartialFill(partialFill, fill))
                    .filter(potentialCrossword -> !visitedGrids.contains(potentialCrossword))
                    .filter(this::allCompleteFillIsValid)
                    .collect(Collectors.toSet());

            // identify complete crosswords
            Set<Crossword> newlyCompletedCrosswords = potentialCrosswords.stream()
                    .filter(CrosswordBuilder::gridIsComplete).collect(Collectors.toSet());

            completeGrids.addAll(newlyCompletedCrosswords);

            Set<Crossword> newIncompleteGrids = Sets.difference(potentialCrosswords, newlyCompletedCrosswords);

            incompleteGrids.addAll(newIncompleteGrids);
        }

        return completeGrids;
    }



    private static boolean fillIsIncomplete(PartialFill partialFill) {
        return partialFill.getLetters().contains(Tile.EMPTY);
    }

    private static boolean fillIsComplete(PartialFill fill) {
        return !fill.getLetters().contains(Tile.EMPTY);
    }

    private boolean allCompleteFillIsValid(Crossword potentialCrossword) {
        return potentialCrossword.toPartialFill().stream()
                .filter(CrosswordBuilder::fillIsComplete)
                .map(PartialFill::toString)
                .allMatch(wordSet::isWordValid);
    }
}
