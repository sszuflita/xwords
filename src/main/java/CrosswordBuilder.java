import com.google.common.collect.ImmutableList;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class CrosswordBuilder {
    Logger log = LoggerFactory.getLogger(CrosswordBuilder.class);

    private List<String> validWords;

    public CrosswordBuilder(List<String> validWords) {
        this.validWords = validWords;
    }

    public static CrosswordBuilder fromPath(Path path) throws IOException {
        return new CrosswordBuilder(
                Files.lines(path)
                        .map(word -> word.split(";")[0])
                        .map(String::toUpperCase)
                        .collect(Collectors.toList()));
    }

    public List<Crossword> solveFromGrid(Crossword crossword) {

        // check all fill is valid
        // find fill to add
        // add it
        // remove it

        while (true) {
            List<PartialFill> partialOrFull = crossword.toPartialFill();
            List<PartialFill> partialsOnly = partialOrFull.stream()
                    .filter(partialFill -> partialFill.getLetters().contains(Tile.EMPTY))
                    .collect(Collectors.toList());
            if (partialsOnly.isEmpty()) {
                break;
            }
            PartialFill partialFill = partialsOnly.iterator().next();

            List<String> validFillOptions = validWords.stream()
                    .filter(word -> matches(word, partialFill))
                    .collect(Collectors.toList());

            String validFill = validFillOptions.get(0);

            fillPartial(partialFill, validFill, crossword);

            Set<PartialFill> allFill = crossword.toPartialFill().stream()
                    .filter(fill -> !fill.getLetters().contains(Tile.EMPTY))
                    .collect(Collectors.toSet());

            Set<PartialFill> allValidFill = allFill.stream()
                    .filter(fill -> validWords.contains(fill.toString()))
                    .collect(Collectors.toSet());

            if (!(allFill.size() == allValidFill.size())) {
                throw new IllegalStateException("Need to undo last move.");
            }
        }


        return ImmutableList.of(crossword);
    }

    private void fillPartial(PartialFill partialFill, String validFill, Crossword crossword) {
        if (partialFill.getOrientation() == Orientation.DOWN) {
            int col = partialFill.getStartCol();
            int startRow = partialFill.getStartRow();
            for (int idx = 0; idx < validFill.length(); idx++) {
                Tile tile = Tile.valueOf(validFill.substring(idx, idx + 1));
                crossword.setValueAtTile(startRow + idx, col, tile);
            }
        } else {
            int row = partialFill.getStartRow();
            int startCol = partialFill.getStartCol();
            for (int idx = 0; idx < validFill.length(); idx++) {
                Tile tile = Tile.valueOf(validFill.substring(idx, idx + 1));
                crossword.setValueAtTile(row, startCol + idx, tile);
            }
        }
    }

    boolean matches(String word, PartialFill partialFill) {
        if (word.length() != partialFill.getLetters().size()) {
            return false;
        }
        return IntStream.range(0, word.length())
                .filter(index -> {
                    Tile tile = partialFill.getLetters().get(index);
                    if (tile.equals(Tile.EMPTY)) {
                        return true;
                    }
                    return tile.name().charAt(0) == word.charAt(index);
                }).count() == word.length();
    }
}
