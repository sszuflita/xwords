package xwords;

import com.google.common.collect.Sets;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import xwords.wordset.BasicWordSet;
import xwords.wordset.WordSet;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import java.util.stream.Collectors;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class CrosswordBuilder {
    Logger log = LoggerFactory.getLogger(CrosswordBuilder.class);

    private WordSet wordSet;

    public CrosswordBuilder(WordSet wordSet) {
        this.wordSet = wordSet;
    }

    public static CrosswordBuilder fromPath(Path path) throws IOException {
        return new CrosswordBuilder(
                new BasicWordSet(Files.lines(path)
                        .map(word -> word.split(";")[0])
                        .map(String::toUpperCase)
                        .collect(Collectors.toSet())));
    }

    public Set<Crossword> solveFromGrid(Crossword base) {

        Queue<Crossword> incompleteGrids = new PriorityQueue<>((o1, o2) -> o2.filledTiles() - o1.filledTiles());
        Set<Crossword> visitedGrids = Sets.newHashSet();
        incompleteGrids.add(base);

        Set<Crossword> completeGrids = Sets.newHashSet();

        while (!incompleteGrids.isEmpty() && completeGrids.size() < 1) {

            Crossword crossword = incompleteGrids.poll();
            visitedGrids.add(crossword);

            // parse into partials
            List<PartialFill> partialOrFull = crossword.toPartialFill();
            List<PartialFill> partialsOnly = partialOrFull.stream()
                    .filter(CrosswordBuilder::fillIsIncomplete)
                    .collect(Collectors.toList());

            // choose a partial to fill
            PartialFill partialFill = partialsOnly.iterator().next();

            // find all valid fills
            Set<String> validFillOptions = wordSet.validWords(partialFill);

            Set<Crossword> potentialCrosswords = validFillOptions.parallelStream()
                    .map(fill -> crossword.withPartialFill(partialFill, fill))
                    .filter(potentialCrossword -> !visitedGrids.contains(potentialCrossword))
                    .filter(this::allCompleteFillIsValid)
                    .collect(Collectors.toSet());

            // identify complete crosswords
            Set<Crossword> newlyCompletedCrosswords = potentialCrosswords.stream()
                    .filter(potentialCrossword -> potentialCrossword.toPartialFill().stream()
                            .allMatch(CrosswordBuilder::fillIsComplete)).collect(Collectors.toSet());

            completeGrids.addAll(newlyCompletedCrosswords);

            Set<Crossword> newIncompleteGrids = Sets.difference(potentialCrosswords, newlyCompletedCrosswords);

            incompleteGrids.addAll(newIncompleteGrids);
        }


        return completeGrids;
    }

    private static boolean fillIsIncomplete(PartialFill partialFill) {
        return partialFill.getLetters().contains(Tile.EMPTY);
    }

    private static boolean fillIsComplete(PartialFill fill) {
        return !fill.getLetters().contains(Tile.EMPTY);
    }

    private boolean allCompleteFillIsValid(Crossword potentialCrossword) {
        return potentialCrossword.toPartialFill().stream()
                .filter(CrosswordBuilder::fillIsComplete)
                .map(PartialFill::toString)
                .allMatch(wordSet::isWordValid);
    }
}
