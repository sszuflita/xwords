import com.google.common.collect.Sets;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class CrosswordBuilder {
    Logger log = LoggerFactory.getLogger(CrosswordBuilder.class);

    private List<String> validWords;

    public CrosswordBuilder(List<String> validWords) {
        this.validWords = validWords;
    }

    public static CrosswordBuilder fromPath(Path path) throws IOException {
        return new CrosswordBuilder(
                Files.lines(path)
                        .map(word -> word.split(";")[0])
                        .map(String::toUpperCase)
                        .collect(Collectors.toList()));
    }

    public Set<Crossword> solveFromGrid(Crossword base) {

        // check all fill is valid
        // find fill to add
        // add it
        // remove it

        //Deque<Crossword> incompleteGrids = new ArrayDeque<>();

        Queue<Crossword> incompleteGrids = new PriorityQueue<>(new Comparator<Crossword>() {
            @Override
            public int compare(Crossword o1, Crossword o2) {

                return o2.filledTiles() - o1.filledTiles();
            }
        });
        Set<Crossword> visitedGrids = Sets.newHashSet();
        incompleteGrids.add(base);

        Set<Crossword> completeGrids = Sets.newHashSet();

        while (!incompleteGrids.isEmpty()) {

            Crossword crossword = incompleteGrids.poll();
            visitedGrids.add(crossword);

            // parse into partials
            List<PartialFill> partialOrFull = crossword.toPartialFill();
            List<PartialFill> partialsOnly = partialOrFull.stream()
                    .filter(partialFill -> partialFill.getLetters().contains(Tile.EMPTY))
                    .collect(Collectors.toList());

            // choose a partial to fill
            PartialFill partialFill = partialsOnly.iterator().next();

            // find all valid fills
            List<String> validFillOptions = validWords.stream()
                    .filter(word -> matches(word, partialFill))
                    .limit(1000)
                    .collect(Collectors.toList());


            Set<Crossword> potentialCrosswords = validFillOptions.parallelStream()
                    .map(fill -> crossword.withPartialFill(partialFill, fill))
                    .filter(potentialCrossword -> !visitedGrids.contains(potentialCrossword))
                    .filter(potentialCrossword ->
                            potentialCrossword.toPartialFill().stream()
                                    .filter(partial -> !partial.getLetters().contains(Tile.EMPTY))
                                    .map(PartialFill::toString)
                                    .allMatch(word -> validWords.contains(word)))
                    .collect(Collectors.toSet());

            // identify complete crosswords
            Set<Crossword> newlyCompletedCrosswords = potentialCrosswords.stream()
                    .filter(potentialCrossword -> potentialCrossword.toPartialFill().stream()
                            .noneMatch(fill -> fill.getLetters().contains(Tile.EMPTY))).collect(Collectors.toSet());

            completeGrids.addAll(newlyCompletedCrosswords);

            if (completeGrids.size() > 10) {
                break;
            }

            Set<Crossword> newIncompleteGrids = Sets.difference(potentialCrosswords, newlyCompletedCrosswords);

            incompleteGrids.addAll(newIncompleteGrids);
        }


        return completeGrids;
    }


    boolean matches(String word, PartialFill partialFill) {
        if (word.length() != partialFill.getLetters().size()) {
            return false;
        }
        return IntStream.range(0, word.length())
                .filter(index -> {
                    Tile tile = partialFill.getLetters().get(index);
                    if (tile.equals(Tile.EMPTY)) {
                        return true;
                    }
                    return tile.name().charAt(0) == word.charAt(index);
                }).count() == word.length();
    }
}
